<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Mycroft — A Predicate Logic Language — Overview / Post-mortem</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Mycroft — A Predicate Logic Language — Overview / Post-mortem</h1>
</header>
<section data-field="subtitle" class="p-summary">
A few years ago, I designed a programming language &amp; wrote a reference implementation for it. This language is the end product of about…
</section>
<section data-field="body" class="e-content">
<section name="4442" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="b67c" id="b67c" class="graf graf--h3 graf--leading graf--title">Mycroft — A Predicate Logic Language — Overview / Post-mortem</h3><p name="fe53" id="fe53" class="graf graf--p graf-after--h3">A few years ago, I designed a programming language &amp; wrote a reference implementation for it. This language is the end product of about five years of thinking about planners, distributed computing, and what it means to make logical inferences about real-world problems. It’s primarily inspired by Prolog, but has a couple ideas imported from Church and from DHT systems like Chord.</p><p name="7695" id="7695" class="graf graf--p graf-after--p">Being a university undergraduate through most of my time designing this system (and not being in mathematics), what I designed doesn’t take advantage of potentially powerful ideas that are common in automated theorem provers, simply because I lacked the background to integrate those ideas. Nevertheless, I feel like Mycroft presents a couple ideas that (while not totally novel) are underrepresented in other planner-based languages, and I have done my best to foreground those.</p><p name="1326" id="1326" class="graf graf--p graf-after--p"><a href="https://github.com/enkiv2/mycroft" data-href="https://github.com/enkiv2/mycroft" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">My implementation</a> looks fairly polished, and is still usable; however, early design choices with regard to how parsing was done have led to <a href="https://github.com/enkiv2/mycroft/issues/2" data-href="https://github.com/enkiv2/mycroft/issues/2" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">major bugs</a> that severely limit the utility of this implementation for the purposes I intended, and these bugs have proven very difficult to track down and solve. Of course, a language with exactly one implementation is of limited value, and I never intended this to be anything more than a proof of concept — I think the ideas presented are valuable enough to warrant a clear writeup, regardless of problems in an unrelated portion of the implementation. I would be interested in seeing some features I integrated into Mycroft appear in more popular languages like Coq, or in planner libraries for non-planer-based languages, even if no independent implementation of Mycroft is ever written.</p><h4 name="77e5" id="77e5" class="graf graf--h4 graf-after--p">Problems with Prolog</h4><p name="9e57" id="9e57" class="graf graf--p graf-after--h4">Most of the design decisions I made in Mycroft are direct reactions to problems I see in Prolog. Some of these problems are almost fatal in terms of potential real-world use. Others are purely conceptual — places where I felt that Prolog’s design subtly failed to reflect some important aspect of problems it could otherwise be applied to.</p><p name="e552" id="e552" class="graf graf--p graf-after--p">Prolog is famously slow. This is not to say that Prolog cannot be optimized. Instead, it’s more accurate to say that a big draw of Prolog is the ability to write programs in the form of an intuitively-understandable set of constraints, without considering execution flow, but that programs so structured will almost inevitably be much slower than similarly naive implementations in imperative languages. Writing efficient Prolog involves tracing execution flow and rearranging the order in which paths are attempted in order to “fail fast” — and while Prolog execution order is fairly easy to understand, highly-optimized Prolog code (replete with cuts and un-idiomatic structures) can be highly unintuitive.</p><p name="71b4" id="71b4" class="graf graf--p graf-after--p">Naive code in Prolog is compact, but its execution is highly repetitive. Most of this repetition would not be necessary, had the planner access to certain out-of-band information. (Of course, since Prolog is standardized, no planner can make unsafe inferences or other ‘intelligent’ optimizations, and the heavy use of planner-execution-order-based optimizations in real Prolog code makes experimenting with optimizations difficult, since messing with the planner is almost guaranteed to break existing programs.)</p><p name="4214" id="4214" class="graf graf--p graf-after--p">Prolog freely mixes determinate (i.e., “pure prolog”) predicates and non-determinate predicates (of the type that would be hidden behind a monad in a modern functional language), which means it’s up to the developer to keep these straight and structure things so debugging is straightforward. This failure to distinguish determinate predicates from those that contain externalities also has implications for potential optimizations.</p><p name="fec7" id="fec7" class="graf graf--p graf-after--p">Furthermore, Prolog’s truth values are wholly binary. A Yes/No value makes sense in a toy planner, but for an expert system (theoretically expected to grow to incorporate new heuristics and provide meaningful advice to a practitioner in a real-world situation) a Yes/No value is of limited utility. Consider the use case of diagnostic aid in medicine (something expert systems have been used in for quite some time): a system that provides an un-annotated list of potential diagnoses is almost useless, unless it has an extremely limited scope; a system that presents a list of potential diagnoses with associated likelihoods based on a combination of base likelihoods, symptoms, and symptom scarcity is much more useful, and one that can proceed to re-weigh the list based on severity and on the risks involved in certain tests and treatments is even more so. Getting such numbers out of Prolog is possible but involves threading probablistic truth and confidence values through the system (possibly many at a time) and implementing the calculation of probabilities yourself, while almost totally circumventing Prolog’s existing system for returning truth values!</p><p name="71f0" id="71f0" class="graf graf--p graf-after--p">Prolog is also limited in the extent to which its structure deals with the expectation of incremental expansion. In part because of the use of binary truth values, there’s no way to express that something is uncomputable as distinct from false (and in fact, the normal way to negate a predicate within another predicate definition is semantically equivalent to ‘has no true expansion’ rather than ‘is false’). So, we’re stuck with a ‘closed world’ assumption. Closed world assumptions have a couple benefits — we can expand the entire herbrand universe and try every possible input to try to satisfy a constraint — but the assumption that our program completely models everything about a problem is, at a fundamental level, never true outside of fairly trivial or purely synthetic situations. We can model all of mathematics starting from first principles, but modeling real-world situations (like disease diagnosis or finding subterranian oil) necessarily means making lossy assumptions and operating on potentially-faulty information. Expert systems are typically loose webs of heuristics, all slightly dubious, and a system based on such heuristics that presents its conclusions as a simple Yes or No value is lying. We should have a little more humility about our conclusions, and so should our machines.</p><h4 name="f7be" id="f7be" class="graf graf--h4 graf-after--p">Getting more LIPS (Logical Inferences Per Second)</h4><p name="4882" id="4882" class="graf graf--p graf-after--h4">Speed is one of the big reasons Prolog is so rarely used. Even when it was popular, it was common to prototype an expert system in Prolog and port it by hand to C++ when it was debugged. Keeping compatibility with Prolog (as noted above) severely limits the set of possible optimizations.</p><p name="edf6" id="edf6" class="graf graf--p graf-after--p">Because Prolog is optimized based on an understanding of traversal order, we can’t really do what Miranda and Erlang do and evaluate multiple paths simultaneously. Anyhow, those languages perform this operation using guards — and the conditions in those guards are essentially predicates themselves. Most of the time, if a guard makes sense and is cheap enough to compute, it becomes the first term in a pred’s definition.</p><p name="cb72" id="cb72" class="graf graf--p graf-after--p">If a single easily-computed condition isn’t enough to determine the success of the entire operation, then don’t we want to execute all branches? Furthermore, if we’re trying to find out how likely something is to be true and using fuzzy truth values of any type, don’t we want to combine the truth values of all branches?</p><p name="1570" id="1570" class="graf graf--p graf-after--p">Today, multitasking is a lot easier than it was in the 70s — our CPUs have multiple cores and we often have access to whole clusters of machines. So, if we have multiple paths to choose from, it makes sense to choose all of them. To this end, Mycroft has a mechanism built into the planner itself which distributes jobs to peers. In the normal case, a predicate with several branches will have each branch sent to a peer — though we implement a cut operation specifically in order to make more traditional guards possible (and this cut operation will force operations to be run in a particular order).</p><p name="029b" id="029b" class="graf graf--p graf-after--p">We also have a lot more ram than we used to, and access to good hashing algorithms. Since determinate predicates will always have the same output with the same input, we can memoize those results and return them without recomputing. Since hostnames and pieces of code will hash to essentially similar formats, we can save memory by controlling our redudancy in a manner likely to produce a pretty even distribution of cached results: we store the result not only in the node that computed it but also in the node whose hostname’s hash is most similar to the hash of the piece of code we’ve run. (We can store it in the N machines with the closest hash, too, in case a machine goes down unexpectedly.)</p><p name="c952" id="c952" class="graf graf--p graf-after--p">The result is that a complicated predicate with N distinct branches can run on N machines within the time it takes to run its most difficult branch, and that difficult branches become easier as more of their solution space is memoized.</p><p name="b3a6" id="b3a6" class="graf graf--p graf-after--p">(Now, internally, I decompose big predicates into pairs of trees — one tree containing zero, one, or two predicates ANDed together, and the other ORed together. These synthetic predicates are callable and can be memoized as long as their children are determinate. So, in practice this means that rather than memoizing every top-level input to a big function, we are memoizing every intermediate operation. We store a lot of values really quickly, but for each one we have replaced a subtree of unknown complexity with a constant-time lookup. In other words, over sufficient iterations, all fully-determinate predicates approach O(1), and this happens much faster than it would if we were just memoizing the top of the tree.)</p><p name="ae9f" id="ae9f" class="graf graf--p graf-after--p">Non-determinate predicates, because they might write something or otherwise modify state, cannot be skipped unless a cut is present. So, best practice is to limit your use of them. Any determinate predicate cannot run a non-determinate predicate.</p><h4 name="ad7e" id="ad7e" class="graf graf--h4 graf-after--p">Opening up the universe</h4><p name="5126" id="5126" class="graf graf--p graf-after--h4">As I mentioned in ‘Problems with Prolog’, a closed universe is implied by two-valued logic, and neither two-value logic nor a closed universe is accurate when it comes to modeling the real world. (Two-valued logic isn’t even technically sufficient to represent the domain of proofs in pure math, as Godel pointed out. But, we aren’t representing this either, except incidentally.)</p><p name="6e1e" id="6e1e" class="graf graf--p graf-after--p">In order to address this, I use a <a href="https://github.com/enkiv2/mycroft/blob/master/internals-CTV.md" data-href="https://github.com/enkiv2/mycroft/blob/master/internals-CTV.md" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">composite truth value </a>(CTV). This is a concept I have taken from Probablistic Logic Networks, but the CTVs I use operate differently from theirs. (If you want to use CTVs in a real system &amp; you have a proper math background, I recommend reading Probablistic Logic Networks and using their system, rather than modeling your implementation on mine.) I have simplified the math as far as I can while keeping this more useful than pure fuzzy values for real decision-making purposes, but anybody familiar with statistics or probability will immediately see room for improvement.</p><p name="e2a4" id="e2a4" class="graf graf--p graf-after--p">I represent CTVs (in an ode to bra-ket notation) as an ordered pair of numbers encased in angle brackets. Each number is between 0 and 1 inclusive. The first number represents ‘truth’, and the second ‘confidence’.</p><p name="4bde" id="4bde" class="graf graf--p graf-after--p">There are a couple ‘special’ CTVs:</p><pre name="f128" id="f128" class="graf graf--pre graf-after--p">&lt;1, 1&gt; is YES (100% true, with 100% confidence)</pre><pre name="c295" id="c295" class="graf graf--pre graf-after--pre">&lt;0, 1&gt; is NO (100% false, with 100% confidence)</pre><pre name="9b30" id="9b30" class="graf graf--pre graf-after--pre">&lt;*, 0&gt; is NC (“No Confidence”, or “No Clue” — any value with a zero confidence value is NC)</pre><pre name="5f35" id="5f35" class="graf graf--pre graf-after--pre">Identities:</pre><pre name="cc2d" id="cc2d" class="graf graf--pre graf-after--pre">For any X,<br>YES AND X =&gt; X<br>NO OR X =&gt; X<br>NC OR X =&gt; X</pre><pre name="645c" id="645c" class="graf graf--pre graf-after--pre">YES OR X =&gt; YES<br>NO AND X =&gt; NO<br>NC AND X =&gt; NC<br>(These follow from the definitions and the math, but they are also used to optimize execution, letting us skip steps when they contain only determinate predicates.)</pre><pre name="a8ff" id="a8ff" class="graf graf--pre graf-after--pre">Otherwise:</pre><pre name="d9c3" id="d9c3" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">&lt;A,B&gt; AND &lt;C,D&gt; =&gt; &lt;A*C,B*D&gt;<br>&lt;A,B&gt; OR &lt;C,D&gt; =&gt; &lt;A*B+C*D-A*C,min(B,D)&gt;</code></pre><p name="b59f" id="b59f" class="graf graf--p graf-after--pre">NC essentially means that there isn’t enough information (or not enough confidence) to make a determination. Any undefined variable is NC; any undefined predicate returns NC; a predicate, when it is asked to evaluate something that doesn’t make sense, should return NC rather than NO.</p><p name="f7a6" id="f7a6" class="graf graf--p graf-after--p">We can lossily ‘flatten’ a CTV into a fuzzy truth value by multiplying the two components.</p><p name="a84f" id="a84f" class="graf graf--p graf-after--p">By supporting NC, we have performed half of the work of integrating the open-world assumption into Mycroft. The other half is our handling of unification — which is to say, not handling it.</p><p name="5f99" id="5f99" class="graf graf--p graf-after--p">Rather than unification (which involves keeping a variable’s value in limbo until all the constraints that affect it are solved, then allowing it to collapse into the appropriate value), we simply make all variables immutable unless unassigned and set the semantics of predicatess such that they return True if their constraint is met on all parameters or if currently-assigned parameters can have a value set that will meet the constraints.</p><p name="eeac" id="eeac" class="graf graf--p graf-after--p">This is different from Prolog since no variable can remain in limbo for very long — if two predicates are in an AND relationship and the first value that the first predicate assigns causes the second predicate to fail, we do not automatically backtrack and try a second possible value — the whole conjunction fails (even if some value that would cause it to succeed exists).</p><p name="86fd" id="86fd" class="graf graf--p graf-after--p">If we want this backtracking behavior, we instead use a function that takes the set of valid inputs for each parameter and iterates over all permutations of all valid inputs, and unifies some parameter to either the first set of values to return a non-NO non-NC value or a list of all sets of values that do so.</p><h4 name="a54e" id="a54e" class="graf graf--h4 graf-after--p">Implementation details</h4><p name="5357" id="5357" class="graf graf--p graf-after--h4">I’ve spent most of this article describing features and attributes of Mycroft that I think would be valuable in planner-based languages generally, and I have tried to keep the discussion mostly relevant to such languages, which are probably implemented very differently from mine. However, I have some pride in parts of Mycroft’s design that are not so portable, so I’d like to briefly mention them here.</p><p name="7044" id="7044" class="graf graf--p graf-after--p">Mycroft implements a REPL, and the REPL has a built-in help system. The help system is really just an associative array between predicate names and short descriptions. This isn’t a hard thing to implement, but I consider it very important — every REPL should have a built-in help system containing information about all built-in functions and any documentation imported from modules, since being able to look at documentation during interactive development is extremely useful. Not only are all of my built-in functions documented here, but all of the language’s documentation is embedded here too, including information about internals and a language tutorial. The man page for the interpreter is actually generated using the internal help system.</p><p name="e235" id="e235" class="graf graf--p graf-after--p">The mechanism for work distribution is round-robin-based, and proceeds to send to the next item in the list if the predicate isn’t answered within a timeout period or the host gets NC as a reply. There’s a similar distribution model for predicate definitions, and for memoized results (which are stored as facts — predicate definitions that, because they have particular parameter values associated with them, have exactly one known return value). Upon getting a shutdown request, a node will use this method to give its internally-stored definitions and memoized results to its peers. When ‘directed mode” is enabled, we perform a sort by hash similarity on this host list before the round-robin mechanism for requests is used, so that no node is overloaded and a result can generally be expected from the first node. The number of nodes to try for a request before giving up is essentially equivalent to the replication factor because of this shared code.</p><h4 name="6ae5" id="6ae5" class="graf graf--h4 graf-after--p">Mycroft internals: networking and message passing</h4><blockquote name="6294" id="6294" class="graf graf--blockquote graf-after--h4">Mycroft polyfills a table called mycnet with the following settings:</blockquote><blockquote name="db8a" id="db8a" class="graf graf--blockquote graf-after--blockquote"><code class="markup--code markup--blockquote-code">mycnet.port=1960<br>mycnet.directedMode=true<br>mycnet.backlog=512</code></blockquote><blockquote name="de8e" id="de8e" class="graf graf--blockquote graf-after--blockquote">The following values:</blockquote><blockquote name="be59" id="be59" class="graf graf--blockquote graf-after--blockquote"><code class="markup--code markup--blockquote-code">mycnet.peers={} -- each element is an array consisting of a hostname followed by a port<br>mycnet.peerHashed={} -- an associative array of the elements of the peers table keyed by the sha256 hash of the serialized elements<br>mycnet.mailbox={} -- a set of requests we have recieved from our peers<br>mycnet.pptr=1 -- the index into the peers table pointing to the &#39;current&#39; selected peer<br>mycnet.forwardedLines={} -- a list of facts we&#39;ve already forwarded, to prevent infinite loops</code></blockquote><blockquote name="b6a1" id="b6a1" class="graf graf--blockquote graf-after--blockquote">And, the following methods:</blockquote><blockquote name="1227" id="1227" class="graf graf--blockquote graf-after--blockquote"><code class="markup--code markup--blockquote-code">mycnet.getPeers(world) -- get a list of peers<br>mycnet.getCurrentPeer(world) <br>mycnet.getNextPeer(world) -- increment mycnet.pptr and return getCurrentPeer<br>mycnet.forwardRequest(world, c) -- send a line of code to next peer<br>mycnet.forwardFact(world, c) -- send a line of code to all peers, if it has not already been sent<br>mycnet.checkMailbox(world) -- get a list of requests from peers<br>mycnet.yield(world) -- process a request from the mailbox, if one exists<br>mycnet.restartServer()<br>mycnet.hashPeers(world, force) -- hash the list of peers. If &#39;force&#39; is set, then rehash all peers; otherwise, hash only if the number of peers has changed</code></blockquote><blockquote name="7503" id="7503" class="graf graf--blockquote graf-after--blockquote">If directedMode is set to false, a request will be sent to the next peer in the peers table, in round-robin fashion.</blockquote><blockquote name="8f87" id="8f87" class="graf graf--blockquote graf-after--blockquote">If directedMode is set to true, then for any given request, the order in which it is sent will be defined by the comparison of some consistent hash (in this case sha256) of the signature of the first predicate with the hash of the entire serialized representation of the peer — we send to the peer with the most similar hash first, and send to all others in order of more or less decreasing similarity. This method of routing is similar to Chord’s DHT routing.</blockquote><blockquote name="a696" id="a696" class="graf graf--blockquote graf-after--blockquote">The rationale behind directedMode is that routing will (in the normal case) require many fewer hops and much less replication will be necessary: even though the routing is arbitrary, it represents a consistent ordering and is more resistant to split-brain problems in a non-fully-connected network than round robin routing in a similarly connected network outside of pathological cases. However, this comes at the cost of making sybil attacks on particular known requests easier: an attacker with the ability to set his own node name can guarantee control over that predicate for as long as he is on the network by ensuring he is always in control of the node name with the closest hash to the predicate (so if the attacker can precompute hash collisions — which may not be so difficult since for performance reasons on embedded hardware we aren’t using a cryptographic hash — he can avoid needing to control most of the network).</blockquote><blockquote name="2c63" id="2c63" class="graf graf--blockquote graf-after--blockquote">Because of the request ordering in directedMode, even if the node that already has the solution for a particular determinate query is not (or no longer) the best candidate in terms of hash similarity, it will as a result of responding to the request distribute the response to be memozied by the most-matching node in its peer list first (meaning that over time the routing improves).</blockquote><blockquote name="f315" id="f315" class="graf graf--blockquote graf-after--blockquote">Memoized results should eventually be put into a priority queue, and a redistribution protocol of memoized results is planned as follows: results for which the current node is the closest hash match should never be discarded by the gc even if they are very stale, and results at the bottom of the queue should be forwarded to the best-matching node that responds within timeout period before being discarded by the gc. A node that is going offline should send its entire ‘world’ to every node, in the order defined by directedMode. (Currently there is no distinction between memoized results and user-defined facts that have been distributed by a peer; however, since only facts are memoized, and facts are small, this may be sufficient.)</blockquote><blockquote name="cdfc" id="cdfc" class="graf graf--blockquote graf-after--blockquote">On NodeMCU (i.e., on an ESP8622), a device <em class="markup--em markup--blockquote-em">should</em> determine whether or not an AP exists with some special name and connect to it if it does, but switch into AP mode and create it if it does not. This is not yet impemented.</blockquote><blockquote name="f098" id="f098" class="graf graf--blockquote graf-after--blockquote">Depending upon whether or not a node is in daemon mode (along with other circumstances), timeouts are changed in order to ensure reliability. Currently, the default timeout for daemon mode for server listen in 300 seconds and the current default timeout outside of daemon mode is one tenth of a second. Timeouts on connections to other peers during request forwarding are set to one tenth of a second. This is hard-coded but subject to future tuning.</blockquote><p name="dd6e" id="dd6e" class="graf graf--p graf-after--blockquote">Mycroft has a fairly conventional error reporting system (similar to that found in Python or Java) for runtime errors, and user code can throw and catch arbitrary errors. This is missing from Prolog, where NO often is overloaded to mean error.</p><p name="0436" id="0436" class="graf graf--p graf-after--p">Mycroft gets rid of Prolog’s awkward syntax for lists in favor of using parentheses and commas, and uses a couple built-in list manipulation predicates to slice and dice lists into other lists, append lists, or get values. (Of course, lists are also immutable, and these list manipulation functions double as conditionals).</p><p name="c0fb" id="c0fb" class="graf graf--p graf-after--p">Mycroft has a ‘paranoid’ and ‘non-paranoid’ mode. In non-paranoid mode, nodes can be added to or removed from the cluster, filesystem operations are possible, modules can be imported, the state of the world can be exported, functions written in Lua can be added or removed, and the interactive interpreter can be spawned. The paranoid mode is essentially sandboxed. One can start a cluster and then immediately set paranoid mode on all nodes other than the one running the interactive interpreter, if one wants to be safe. (Or, you can set paranoid mode on the interactive interpreter too, though that makes it difficult to perform some operations.)</p><p name="3560" id="3560" class="graf graf--p graf-after--p">I’m proud of Mycroft’s syntax for preserving everything I like about Prolog’s syntax and getting rid of everything I dislike:</p><h4 name="69d1" id="69d1" class="graf graf--h4 graf-after--p">Mycroft syntax</h4><blockquote name="d1d9" id="d1d9" class="graf graf--blockquote graf-after--h4">Mycroft has a prolog-like syntax, consisting of predicate definitions and queries.</blockquote><blockquote name="ef6d" id="ef6d" class="graf graf--blockquote graf-after--blockquote">A predicate definition is of the form:</blockquote><blockquote name="bf44" id="bf44" class="graf graf--blockquote graf-after--blockquote"><code class="markup--code markup--blockquote-code">det predicateName(Arg1, Arg2...) :- predicateBody.</code></blockquote><blockquote name="dae2" id="dae2" class="graf graf--blockquote graf-after--blockquote">where predicateBody consists of a list of references to other predicates and truth values.</blockquote><blockquote name="9880" id="9880" class="graf graf--blockquote graf-after--blockquote">A predicate that is marked ‘det’ is determinate — if it ever evaluates to a different value than it has cached, an error is thrown. An indeterminate predicate can be marked ‘nondet’ instead, meaning that its return value can change and so results from it will not be memoized.</blockquote><blockquote name="9af1" id="9af1" class="graf graf--blockquote graf-after--blockquote">A predicate body is of the form:</blockquote><blockquote name="f4a0" id="f4a0" class="graf graf--blockquote graf-after--blockquote"><code class="markup--code markup--blockquote-code">item1, item2... ; itemA, itemB...</code></blockquote><blockquote name="ce19" id="ce19" class="graf graf--blockquote graf-after--blockquote">where each item is either a reference to a predicate or a truth value. Sections separated by ‘;’ are ORed together, while items separated by ‘,’ are ANDed together.</blockquote><blockquote name="0458" id="0458" class="graf graf--blockquote graf-after--blockquote">A reference to a predicate is of the form predicateName(Arg1, Arg2…)</blockquote><blockquote name="f038" id="f038" class="graf graf--blockquote graf-after--blockquote">A truth value (or composite truth value, or CTV) is of the form</blockquote><blockquote name="e77a" id="e77a" class="graf graf--blockquote graf-after--blockquote"><code class="markup--code markup--blockquote-code">&lt;Truth, Confidence&gt;</code></blockquote><blockquote name="8ed1" id="8ed1" class="graf graf--blockquote graf-after--blockquote">where both Truth and Confidence are floating point values between 0 and 1. &lt;X| is syntactic sugar for &lt;X, 1.0&gt;; |X&gt; is syntactic sugar for &lt;1.0, X&gt;; YES is syntactic sugar for &lt;1.0, 1.0&gt;; NO is syntactic sugar for &lt;0.0, 1.0&gt;; and, NC is syntactic sugar for &lt; X, 0.0&gt; regardless of the value of X.</blockquote><blockquote name="4179" id="4179" class="graf graf--blockquote graf-after--blockquote">A query is of the form:</blockquote><blockquote name="b61c" id="b61c" class="graf graf--blockquote graf-after--blockquote"><code class="markup--code markup--blockquote-code">?- predicateBody.</code></blockquote><blockquote name="ab05" id="ab05" class="graf graf--blockquote graf-after--blockquote">The result of a query will be printed to standard output.</blockquote><blockquote name="62b7" id="62b7" class="graf graf--blockquote graf-after--blockquote">Comments begin with a hash mark:</blockquote><blockquote name="fcda" id="fcda" class="graf graf--blockquote graf-after--blockquote"><code class="markup--code markup--blockquote-code"># This is a &quot;comment&quot;.</code></blockquote><blockquote name="5303" id="5303" class="graf graf--blockquote graf-after--blockquote">Variables begin with a capital letter, and are immutable:</blockquote><blockquote name="44ed" id="44ed" class="graf graf--blockquote graf-after--blockquote"><code class="markup--code markup--blockquote-code">?- set(X, &quot;Hello&quot;), print(X). # prints &quot;Hello&quot;<br>?- set(X, &quot;Hello&quot;), set(X, &quot;Goodbye&quot;). # fails<br>?- set(x, &quot;Hello&quot;). # also fails</code></blockquote><blockquote name="5826" id="5826" class="graf graf--blockquote graf-after--blockquote">Strings are surrounded by double quotes, however, words containing only letters, numbers, and underscores that do not begin with an uppercase letter will be evaluated as strings. Unbound variables will also evaluate as the string value of their names:</blockquote><blockquote name="170a" id="170a" class="graf graf--blockquote graf-after--blockquote"><code class="markup--code markup--blockquote-code">?- equal(hello, &quot;hello&quot;). # true<br>?- equal(X, &quot;X&quot;). # also true</code></blockquote><blockquote name="a458" id="a458" class="graf graf--blockquote graf-after--blockquote graf--trailing">For some simple examples, see <a href="https://github.com/enkiv2/mycroft/blob/master/test.myc" data-href="https://github.com/enkiv2/mycroft/blob/master/test.myc" class="markup--anchor markup--blockquote-anchor" rel="noopener" target="_blank">the test suite</a>.</blockquote></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@enkiv2" class="p-author h-card">John Ohno</a> on <a href="https://medium.com/p/e357fe80d53"><time class="dt-published" datetime="2018-01-05T20:33:55.088Z">January 5, 2018</time></a>.</p><p><a href="https://medium.com/@enkiv2/mycroft-a-predicate-logic-language-overview-post-mortem-e357fe80d53" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on September 18, 2020.</p></footer></article></body></html>