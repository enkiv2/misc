<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Programming as expression</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Programming as expression</h1>
</header>
<section data-field="subtitle" class="p-summary">
Every computer program is also a persuasive essay &amp; a work of interactive performance art, and if you don’t consider it through those…
</section>
<section data-field="body" class="e-content">
<section name="9e9e" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="8472" id="8472" class="graf graf--h3 graf--leading graf--title">Programming as expression</h3><p name="e214" id="e214" class="graf graf--p graf-after--h3">Every computer program is also a persuasive essay &amp; a work of interactive performance art, and if you don’t consider it through those lenses when writing it you run the risk of persuading people of something you don’t agree with. A lot of my criticisms of Medium &amp; Mastodon basically come down to this: there’s an admirable and explicitly-stated philosophy that hasn’t really been allowed to transform deeper technical decisions, resulting in a contradiction between intent and function, because certain things are assumed to be ‘the way things are’ instead of a decision.</p><p name="197c" id="197c" class="graf graf--p graf-after--p">In computing, nothing is ‘the way things are’ (save the halting problem, NP-completeness, &amp; other similar mathematical restrictions taught to every freshman CS student). Not only that, but doing things the right way yourself is usually <em class="markup--em markup--p-em">actually</em> easier than using pre-made components that are a poor fit for the problem — standard components actually waste more time in many cases. Some baseline willingness to expand the mind is a necessary skill for anyone who identifies as ‘technical’, and with this baseline, use of poor tooling is rarely justified on the grounds of engineer-time: it creates the kind of technical debt that reliably produces technical bankruptcy (as the resulting code must inevitably be torn down to minimize damage).</p><p name="0652" id="0652" class="graf graf--p graf-after--p">The two key components to this kind of failure are an emphasis on sunk cost (manifesting as an unwillingness to reinvent the wheel or an exaggerated sense of the value of existing third party tools) and a lack of imagination (manifesting as an expectation that even if familiar tools are a poor fit, unfamiliar tools can be no better). We ought to be very alert to opportunities to usefully reinvent the wheel, as developers: every time we do, we find new ways to improve it. Somebody clever once said “the great thing about reinventing the wheel is you get to make a round one”. This is evocative, but I think most of the time we get so focused on the wheel that we don’t notice that in our target environment we’d have a lot fewer problems if we used skis.</p><p name="219f" id="219f" class="graf graf--p graf-after--p">Framing our projects as expressions of an underlying philosophy highlights instances where decisions we would otherwise make without consideration actually work against us.</p><p name="2bb2" id="2bb2" class="graf graf--p graf-after--p">To give an example — web standards assume but do not enforce that all addresses refer permanently to an immutable piece of information, but the use of hostnames in URLs (as opposed to content hashes) makes traffic-based outages (like slashdotting &amp; DoS attacks) unavoidable and broken links in the case of the loss of a host inevitable, while encouraging domain squatting &amp; the use of CGI to serve uncacheable dynamic content; ultimately, permanent addresses &amp; immutable objects are not functionally an attribute of the web, and we have all sorts of facilities to work around that (like large data centers, services like cloudflare, and the 3xx, 4xx, and 5xx HTTP error codes) and all sorts of early web features that simply cannot be expected to work as intended (like the 3xx error codes, partial fetches, and hyperlinks themselves). The technology necessary for permanent addressing &amp; immutable content without centralized control was available to Tim Berners-Lee in 1989 (and should have been familiar to him), so had he considered the risks to the conceptual integrity of hypertext, he would not have built the system this way.</p><p name="a840" id="a840" class="graf graf--p graf-after--p graf--trailing">Framing our projects as expressions of an underlying philosophy also makes behavior more easily predicted and understood: a philosophically internally-consistent system will behave in ways that can be derived a priori from the philosophy in most cases, and will not behave in ways that conflict with that philosophy in cases when the most ‘right’ solution is unclear but there are many obvious ‘wrong’ ones.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@enkiv2" class="p-author h-card">John Ohno</a> on <a href="https://medium.com/p/b7aa204851b"><time class="dt-published" datetime="2018-11-14T13:10:51.820Z">November 14, 2018</time></a>.</p><p><a href="https://medium.com/@enkiv2/programming-as-expression-b7aa204851b" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on September 18, 2020.</p></footer></article></body></html>