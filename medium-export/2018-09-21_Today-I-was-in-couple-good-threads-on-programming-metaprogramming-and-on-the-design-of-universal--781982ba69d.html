<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Today I was in couple good threads on programming/metaprogramming and on the design of universal…</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Today I was in couple good threads on programming/metaprogramming and on the design of universal…</h1>
</header>
<section data-field="subtitle" class="p-summary">
The first thread is longer and has more drift, but it’s worth digging through, because it’s mostly a meditation on what kind of language…
</section>
<section data-field="body" class="e-content">
<section name="77cd" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="8213" id="8213" class="graf graf--p graf--leading">Today I was in couple good threads on <a href="https://cybre.space/@nonphatic/100759040204408603" data-href="https://cybre.space/@nonphatic/100759040204408603" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">programming/metaprogramming</a> and on <a href="https://retro.social/@freakazoid/100760945401213374" data-href="https://retro.social/@freakazoid/100760945401213374" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">the design of universal undo</a>. I feel blessed by the awesome folks who argue about computers with me on mastodon.</p><p name="16c9" id="16c9" class="graf graf--p graf-after--p">The first thread is longer and has more drift, but it’s worth digging through, because it’s mostly a meditation on what kind of language we might want (what kind of facilities and attributes we might want) for small computing (i.e., for exploration, prototyping, and a composition-friendly general computing environment).</p><p name="4e52" id="4e52" class="graf graf--p graf-after--p">My take on it is that we want:<br>1) homogeneity — all mechanisms should be in the same language and be equally easy to edit (rather than having distinct domains like compiled c programs vs shell scripts, or having separate privilege levels like kernel vs user space); because this is a small-computing environment, neither security nor performance should take priority over flexibility<br>2) support for an agglutanative / syntax-lite style — the need to produce boilerplate &amp; declarations, explicit types, and any constraints that require conceptually similar things to be visually very different all get in the way of iteration, while the likes of lisp, forth, rebol, bourne-style shells, APL, and io all present a style more well-suited to long-term iteration on a persistent interactive REPL-like environment<br>3) both function-like, message-like, and pipe-like code composition — different kinds of data flows and different kind of modularization have different patterns of behavior that are convenient for them<br>4) backtracking and pattern matching as a built-in facility — constraint programming is rare as a feature in imperative-style languages, but a declarative style is a very powerful tool for rapid iteration, because it means that not-yet-implemented code can literally run so long as the requirements for that code are well-defined</p><p name="5c04" id="5c04" class="graf graf--p graf-after--p graf--trailing">In the second thread, the idea of system- or vm-level backtracking exposed as both a mechanism for capabilities-based security and fast constraint solving in user code is explored. My take is:<br>1) if we combine copy-on-write with the parallelism supported by the underlying host system, we can get fast and easy constraint solving for the whole system<br>2) this is completely compatible with global forking undo on the vm level<br>3) it can be conveniently implemented in terms of a journal and a vm image</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@enkiv2" class="p-author h-card">John Ohno</a> on <a href="https://medium.com/p/781982ba69d"><time class="dt-published" datetime="2018-09-21T02:34:00.850Z">September 21, 2018</time></a>.</p><p><a href="https://medium.com/@enkiv2/today-i-was-in-couple-good-threads-on-programming-metaprogramming-and-on-the-design-of-universal-781982ba69d" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on September 18, 2020.</p></footer></article></body></html>