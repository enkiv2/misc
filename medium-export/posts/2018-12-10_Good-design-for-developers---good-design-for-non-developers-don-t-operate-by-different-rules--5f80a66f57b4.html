<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Good design for developers &amp; good design for non-developers don’t operate by different rules.</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Good design for developers &amp; good design for non-developers don’t operate by different rules.</h1>
</header>
<section data-field="subtitle" class="p-summary">
The primary difference between a programming language &amp; an application GUI is the expected acceptable tradeoff between initial learning…
</section>
<section data-field="body" class="e-content">
<section name="cf37" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="be00" id="be00" class="graf graf--p graf--leading">Good design for developers &amp; good design for non-developers don’t operate by different rules. Devs aren’t happy needing to memorize manuals, and end users can &amp; will learn things if it makes their lives easier.</p><p name="8360" id="8360" class="graf graf--p graf-after--p">The primary difference between a programming language &amp; an application GUI is the expected acceptable tradeoff between initial learning curve steepness &amp; flexibility.</p><p name="c68e" id="c68e" class="graf graf--p graf-after--p">If you can get more flexibility without making your initial learning curve steeper, you will please the <em class="markup--em markup--p-em">entire </em>spectrum of users. (Hint: you probably can. Think about it.)</p><p name="55fa" id="55fa" class="graf graf--p graf-after--p">I’ve said all this before, but maybe saying it this way is more understandable.</p><p name="3da5" id="3da5" class="graf graf--p graf-after--p">Consider what it would be like if, as part of your windowing environment or widget toolkit, every application had, built-in, the ability to perform a for-loop-like or while-loop-like behavior whose conditions are defined by the user. Just importing one (simple) structure from programming &amp; making it universal to all GUI apps would have an enormous effect on flexibility, while remaining totally accessible to non-technical users. (No user is unable to imagine the concept of ‘do it 10 times’)</p><p name="04e0" id="04e0" class="graf graf--p graf-after--p">Interface usability in a nutshell: minimize how often the simplest way to do a thing the user wants to do is 1) hard to imagine before you see it, or 2) hard to understand once observed. (Assume the user is more creative than you &amp; less well-informed.)</p><p name="9a7a" id="9a7a" class="graf graf--p graf-after--p">(Like all interface usability concerns, this applies equally to programming languages as to GUI applications, because the only real difference between the two is how much of the manual you can assume the user is willing to read)</p><p name="a74b" id="a74b" class="graf graf--p graf-after--p">This is similar to the ‘law of least surprise’, but it also makes explicit some things about the normal formulation of law of least surprise that are easily ignored. Also, where the law of least surprise is post-hoc (about whether or not the user can predict and understand individual actions), this formulation is about planning whole sequences of interactions.</p><p name="fcea" id="fcea" class="graf graf--p graf-after--p">Often, simple &amp; predictable components or steps cannot be combined to produce comparably simple &amp; predictable large-scale solutions. For instance, assembly language instructions are incredibly simple and predictable, but understanding large assembly-language programs is hard.</p><p name="1e9a" id="1e9a" class="graf graf--p graf-after--p graf--trailing">When the simplicity of components doesn’t scale, you end up with write-only languages: it’s easy to figure out how to solve a problem because each step is easily understood in certain circumstances (known to the programmer), but those circumstances must be reverse-engineered by a maintainer if a change is needed and any information is missing — for instance, to determine the intended behavior, correctness, or input format of some code.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@enkiv2" class="p-author h-card">John Ohno</a> on <a href="https://medium.com/p/5f80a66f57b4"><time class="dt-published" datetime="2018-12-10T13:42:01.007Z">December 10, 2018</time></a>.</p><p><a href="https://medium.com/@enkiv2/good-design-for-developers-good-design-for-non-developers-dont-operate-by-different-rules-5f80a66f57b4" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on March 29, 2021.</p></footer></article></body></html>