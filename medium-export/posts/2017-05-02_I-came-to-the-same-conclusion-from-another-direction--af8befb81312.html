<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>I came to the same conclusion from another direction:</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">I came to the same conclusion from another direction:</h1>
</header>
<section data-field="subtitle" class="p-summary">
Thinking in terms of maintainability under mental load (i.e., debugging on little sleep with a deadline / whatever), idioms trade space in…
</section>
<section data-field="body" class="e-content">
<section name="6f8c" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="f490" id="f490" class="graf graf--p graf--leading">I came to the same conclusion from another direction:</p><p name="495b" id="495b" class="graf graf--p graf-after--p">Thinking in terms of maintainability under mental load (i.e., debugging on little sleep with a deadline / whatever), idioms trade space in code for mental load, so long as those idioms are appropriately applied.</p><p name="4639" id="4639" class="graf graf--p graf-after--p">In other words, if you write code with the awareness that every idiomatic structure is one chunk and every major divergence from idiom counts as a chunk (and everything that looks like an idiomatic use but actually relies on some minor detail to change the behavior non-trivially — i.e., obfuscation — counts as several chunks, since at the very least the programmer must identify the idiom then identify the actual behavior), appropriate use of idioms can reduce the code size in terms of number of chunks (and thus reduce mental load). This corresponds to engineer-time much better than number of lines or number of characters do.</p><p name="b243" id="b243" class="graf graf--p graf-after--p">When people complain about boilerplate, they are usually complaining about the misuse of idioms (either enforced by language or style guides or enforced by a programmer’s ignorance): a java program written in ‘good’ java style for solving a problem not well suited to that set of abstractions can easily contain more trivial classes / beans / interfaces than an equivalent program in a more well-suited language contains lines of code — in other words, the chunk count actually increased by trying to force the solution into an inappropriate set of idioms, because in addition to solving the actual problem the program also solves the additional non-trivial problem of idiom conversion.</p><p name="8770" id="8770" class="graf graf--p graf-after--p">When I am not developing interactively or writing throw-away code on a deadline, I avoid features that allow me to compress many mental chunks into a small number of characters (particularly in languages like python, where such features are extremely powerful), because I know that no matter what I do, a bug in such a heavy line will be many times harder to fix (and the behavior many times harder to reason about) as soon as I’ve GC’d my mental model of it &amp; no longer have a detailed internalized map of execution in working memory.</p><p name="d717" id="d717" class="graf graf--p graf-after--p graf--trailing">I have a coworker who favors such constructs, and finds idiomatic code hard to understand. However, he thinks about code in terms of how the interpreter or compiler works (learning languages by reading their implementations) and his chunk size is determined by implementation AST — in other words, he has an unusual way of thinking about and reading code that is unconcerned with programmer intent. I would recommend anyone who does not model programs in this way to embrace the force multiplier of careful idiom use.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@enkiv2" class="p-author h-card">John Ohno</a> on <a href="https://medium.com/p/af8befb81312"><time class="dt-published" datetime="2017-05-02T14:00:40.014Z">May 2, 2017</time></a>.</p><p><a href="https://medium.com/@enkiv2/i-came-to-the-same-conclusion-from-another-direction-af8befb81312" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on March 29, 2021.</p></footer></article></body></html>