<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Enough to be Dangerous</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Enough to be Dangerous</h1>
</header>
<section data-field="subtitle" class="p-summary">
A really important idea in programming-language-design-as-UI-design is time-to-ETBD.
</section>
<section data-field="body" class="e-content">
<section name="22f6" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="e9a9" id="e9a9" class="graf graf--h3 graf--leading graf--title">Enough to be Dangerous</h3><p name="50af" id="50af" class="graf graf--p graf-after--h3">A really important idea in programming-language-design-as-UI-design is time-to-ETBD.</p><p name="4145" id="4145" class="graf graf--p graf-after--p">How much time does it take to go from zero to Enough To Be Dangerous (i.e., enough knowledge to be able to reliably make turing-complete constructs with conditionals and simple math). If you’ve got ETBD in some language, then you can write anything in it (barring IO), given enough effort, even without learning any more features.</p><p name="8b27" id="8b27" class="graf graf--p graf-after--p">Some languages have a really fast ETBD — prolog, forth, basic, python. Esolangs often don’t even have features beyond the ETBD level (brainfuck and unlambda for instance).</p><p name="646e" id="646e" class="graf graf--p graf-after--p">A non-programmer can learn all of brainfuck in ten minutes. They are now a minimum-viable-programmer. Nevertheless, actually doing anything in it is a turing tarpit, and this is true of any language when you get to ETBD status in it.</p><p name="7774" id="7774" class="graf graf--p graf-after--p">Having a fast time-to-ETBD is important for a language because you need to get there before the user is ready to learn anything else. Optimizing documentation for time-to-ETBD is important for the same reason.</p><p name="c1b6" id="c1b6" class="graf graf--p graf-after--p">The amount of effort it takes to get to ETBD in Java, C, or C++ &amp; the number of new concepts that need to be paid tribute to (if not actually understood) is a barrier to new programmers.</p><p name="68a9" id="68a9" class="graf graf--p graf-after--p">(Modern GUIs never reach an ETBD point except ones intended as languages. As a result, modern GUIs, as framed as programming languages, are essentially dysfunctional. Likewise, lots of systems are ostensibly non-turing-complete but have Weird Machines that allow you to glitch them into turing-complete behavior — like CSS or truetype fonts; since finding these features is not really possible for new users, it doesn’t count toward learning curve.)</p><p name="0d58" id="0d58" class="graf graf--p graf-after--p">Minimizing time-to-ETBD means minimizing the amount of time, effort, and documentation to go from total non-programmer to minimum-viable-programmer.</p><p name="0dde" id="0dde" class="graf graf--p graf-after--p graf--trailing">I do not consider the web stack to be a meaningful improvement over other systems by this metric, unless you consider obtaining an environment part of time-to-ETBD and do <em class="markup--em markup--p-em">not</em> consider knowing that such an environment exists as part of it. Even then, home computers booting into BASIC and shipping with manuals starting with simple example programs are better time-to-ETBD in that sense than browsers — the time from first computer purchase to being able to write simple turing-complete programs reliably on 8-bit micros could be years (or could be negative, if the salesman at the computer store taught you to program on a demo machine). There are people who have been using web browsers for twenty years without ever suspecting that they could write a program that would run in one with a text editor.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@enkiv2" class="p-author h-card">John Ohno</a> on <a href="https://medium.com/p/8ad4ba875ff6"><time class="dt-published" datetime="2018-06-15T11:00:22.448Z">June 15, 2018</time></a>.</p><p><a href="https://medium.com/@enkiv2/enough-to-be-dangerous-8ad4ba875ff6" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on March 29, 2021.</p></footer></article></body></html>