<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Kaukatcr: an experiment in language design for multi-dimensional spaces</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Kaukatcr: an experiment in language design for multi-dimensional spaces</h1>
</header>
<section data-field="subtitle" class="p-summary">
One of the various projects associated with Project Xanadu™[1] was ZigZag™, a kind of organizer system or mind-mapping tool built around…
</section>
<section data-field="body" class="e-content">
<section name="3825" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="fd8d" id="fd8d" class="graf graf--h3 graf--leading graf--title">Kaukatcr: an experiment in language design for multi-dimensional spaces</h3><p name="28c5" id="28c5" class="graf graf--p graf-after--h3">One of the various projects associated with Project Xanadu™[1] was ZigZag™, a kind of organizer system or mind-mapping tool built around twisted multi-dimensional spaces called ZZStructures.</p><p name="ec1c" id="ec1c" class="graf graf--p graf-after--p">From the beginning, we wanted to make this system scriptable. Some existing internal implementations supported scripting in conventional languages, and Ted wanted a spreadsheet-formula-like language (since he thought of a ZZStructure as a kind of spreadsheet whose rows and columns were set free from their grid and tangled up in arbitrarily expressive ways).</p><p name="ee85" id="ee85" class="graf graf--p graf-after--p">When I was there, Jon Kopetz and I came up with the concept of a language that took more full advantage of the structures available, and I wrote a proof-of-concept implementation. It was not persued further — the language wasn’t really accessible to non-programmers the way a formula system might be, and we had other priorities — but I consider some of the ideas valuable, since, for all its limitations, it sits at the intersection of literate programming, stack programming, and visual programming.</p><h4 name="032c" id="032c" class="graf graf--h4 graf-after--p">Quick legal note</h4><p name="991f" id="991f" class="graf graf--p graf-after--h4">Project Xanadu produces a lot of code internally — a lot more than ever gets released — and a lot of internal documents and discussions. The code I’m linking to was written independently, from memory, based on things that I wrote for Xanadu. However, it is not officially blessed by the project, so the various trademarks (Project Xanadu™, ZigZag™, the flaming X logo, and probably others) don’t apply. As far as I am aware, this material does not violate any trade secrets — all trade-secrets related to ZigZag™ that I was privy to have been made public. Also, while patents related to this tech were filed, to my knowledge no applicable patents are currently in force.</p><p name="c5f1" id="c5f1" class="graf graf--p graf-after--p">From now on, I will refer to ZigZag™-like systems as ZZ. These ideas do not necessarily rely upon all of the features of ZigZag™, but may be applied to any system based on a ZZStructure. Also, I hate typing trademark slugs.</p><h4 name="b5fc" id="b5fc" class="graf graf--h4 graf-after--p">A crash course in ZZStructures and ZZ interface conventions</h4><p name="3db9" id="3db9" class="graf graf--p graf-after--h4">A ZZStructure is a collection of ‘cells’ — objects containing a value and a string-keyed associative array of pairs of pointers to other cells.[2]</p><p name="3d2e" id="3d2e" class="graf graf--p graf-after--p">A programmer might conceptualize a cell as the intersection of arbitrarily-many doubly-linked lists, each with a name. Alternately, they might see a cell as a point in a tangled multi-dimensional space (hence why the names given to these lists are called “dimensions”).</p><figure name="51d6" id="51d6" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*qoCgbVGndqLaf8JtJM2KCQ.jpeg" data-width="473" data-height="273" src="https://cdn-images-1.medium.com/max/800/1*qoCgbVGndqLaf8JtJM2KCQ.jpeg"><figcaption class="imageCaption">A very twisted portion of a ZZStructure, with two visible dimensions, as seen in the gzz implementation of ZigZag</figcaption></figure><p name="c90a" id="c90a" class="graf graf--p graf-after--figure">A full ZZStructure implementation can be written in <a href="https://github.com/enkiv2/misc/blob/master/ds-lib/ZZCell.py" data-href="https://github.com/enkiv2/misc/blob/master/ds-lib/ZZCell.py" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">200 lines of python</a>. For the sake of explanation, here is an even-more-simplified version:</p><pre name="557e" id="557e" class="graf graf--pre graf-after--p">cells=[]</pre><pre name="1569" id="1569" class="graf graf--pre graf-after--pre">class ZZCell:<br>    def __init__(self, value=None):<br>        global cells<br>        self.cid=len(cells)<br>        self.value=value<br>        self.connections={}<br>        self.connections[True]={}<br>        self.connections[False]={}<br>        cells.append(self)<br>    # core operations<br>    def getValue(self):<br>        &quot;&quot;&quot; get cell&#39;s value. Use this, rather than the value attribute, unless you specifically don&#39;t want to handle clones &quot;&quot;&quot;<br>        return self.cloneHead().value<br>    def getNext(self, dim, pos=True):<br>        if dim in self.connections[pos]:<br>            return self.connections[pos]<br>        return None<br>    def insert(self, dim, val, pos=True):<br>        &quot;&quot;&quot; like setNext, except it will repair exactly one connection &quot;&quot;&quot;<br>        if(dim in self.connections[pos]):<br>            temp=self.connections[pos][dim]<br>            self.setNext(dim, val, pos)<br>            val.setNext(temp, val, pos)<br>        else:<br>            self.setNext(dim, val, pos)<br>    def breakConnection(self, dim, pos=True):<br>        if self.getNext(dim, pos):<br>            temp=self.connections[pos][dim]<br>            temp.connections[not pos][dim]=None<br>            self.connections[pos][dim]=None<br>    def clone(self):<br>        &quot;&quot;&quot; create a clone &quot;&quot;&quot;<br>        c=ZZCell()<br>        self.rankHead(&quot;d.clone&quot;, True).setNext(&quot;d.clone&quot;, c)<br>        return c<br>    def cloneHead(self):<br>        return self.rankHead(&quot;d.clone&quot;)<br>    # underlying operations (usually not exposed through the UI)<br>    def setNext(self, dim, val, pos=True):<br>        self.connections[pos][dim]=val<br>        val.connections[not pos][dim]=self<br>    def rankHead(self, dim, pos=False):<br>        &quot;&quot;&quot; Get the head (or tail) of a rank &quot;&quot;&quot;<br>        curr=self<br>        n=curr.getNext(dim, pos)<br>        while(n):<br>            if(n==self):<br>                break    # handle ringranks<br>            curr=n<br>            n=curr.getNext(dim, pos)<br>        return curr<br>    def getDims(self):<br>        return list(set(self.connections[True].keys() + self.connections[False].keys()))</pre><p name="c2be" id="c2be" class="graf graf--p graf-after--pre">Generally speaking, a conventional ZZ interface (a “view”) will consist of two panes, each with a particular cell selected and with two or three dimensions mapped to the spacial dimensions of the pane. Users navigate both panes simultaneously, or use each pane to view different aspects of the same cell (in the form of connections along different dimensions).</p><p name="c69e" id="c69e" class="graf graf--p graf-after--p">This article will be illustrated with hand-drawn images of a simplified ZZ interface of this type. ZZ keybindings and interactions are beyond the scope of this article, although I encourage those interested to read <a href="http://xanadu.com/zigzag/" data-href="http://xanadu.com/zigzag/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">the official documentation in the ‘starter kit’</a> and watch <a href="https://www.youtube.com/watch?v=YWDh7TwaaxU" data-href="https://www.youtube.com/watch?v=YWDh7TwaaxU" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">the demonstration video</a>.</p><figure name="9d2e" id="9d2e" class="graf graf--figure graf--iframe graf-after--p"><iframe src="https://www.youtube.com/embed/YWDh7TwaaxU?feature=oembed" width="640" height="480" frameborder="0" scrolling="no"></iframe><figcaption class="imageCaption">A demonstration of the use of ZigZag for organic chemistry</figcaption></figure><figure name="65e4" id="65e4" class="graf graf--figure graf--iframe graf-after--figure"><iframe src="https://www.youtube.com/embed/n22A-Say7do?feature=oembed" width="700" height="393" frameborder="0" scrolling="no"></iframe><figcaption class="imageCaption">Ted Nelson explains ZigZag</figcaption></figure><figure name="f223" id="f223" class="graf graf--figure graf--iframe graf-after--figure"><iframe src="https://www.youtube.com/embed/6yFcJXBMGQQ?feature=oembed" width="700" height="393" frameborder="0" scrolling="no"></iframe><figcaption class="imageCaption">Another demonstration of ZigZag, this time at the Internet Archive</figcaption></figure><h4 name="e748" id="e748" class="graf graf--h4 graf-after--figure">Kaukatcr</h4><p name="6e8a" id="6e8a" class="graf graf--p graf-after--h4"><a href="https://github.com/enkiv2/misc/blob/master/ds-lib/kaukatcr.py" data-href="https://github.com/enkiv2/misc/blob/master/ds-lib/kaukatcr.py" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Kaukatcr</a> (pronounced “cowcatcher”[3]) is a stack-based language modeled loosely on Forth. It avoids tokenization by treating cell boundaries as word boundaries. Like Forth, any word that is neither a built-in nor found in the dictionary of defined functions will be treated as data and pushed onto the stack.</p><p name="504e" id="504e" class="graf graf--p graf-after--p">Kaukatcr has an ‘interpreter head’ — a cell that corresponds to the beginning of the program. The stack hangs off the interpreter head along the dimension ‘d.stack’ ; the names of defined functions hang off it along ‘d.funcs’; the call stack hangs off it along ‘d.call’; the interpreter iterates along ‘d.exec’.</p><p name="55e3" id="55e3" class="graf graf--p graf-after--p">Function definitions hang off their names along ‘d.exec’. ‘d.branch’ points to the targets of conditional jumps.</p><p name="c157" id="c157" class="graf graf--p graf-after--p">By convention, we hang comments off of our code along ‘d.comment’.</p><p name="a429" id="a429" class="graf graf--p graf-after--p">For the sake of readability for non-Forth-programmers, a few Forth keywords have been renamed: ‘:’ becomes ‘def’ and ‘;;’ becomes ‘end’.[4] Function definition, nevertheless, works approximately the same way:</p><pre name="5432" id="5432" class="graf graf--pre graf-after--p">: 2dup swap dup rot dup ;;</pre><p name="27a1" id="27a1" class="graf graf--p graf-after--pre">becomes:</p><figure name="fc3f" id="fc3f" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Edyw-UEqbu-TQBI5ZCnaeA.png" data-width="339" data-height="469" src="https://cdn-images-1.medium.com/max/800/1*Edyw-UEqbu-TQBI5ZCnaeA.png"></figure><p name="4353" id="4353" class="graf graf--p graf-after--figure">The ‘ret’ is required because we do not automatically return from calls when they exit — without the ‘ret’, the program will terminate when it walks off the end of a rank. This makes it a little easier to exit a program early, and so supports interactive editing — one can observe the stack during execution of an unfinished program, perhaps edit it, and then resume at an exit point.</p><p name="6ac6" id="6ac6" class="graf graf--p graf-after--p">Once the code defining that function has been read, our interpreterHead will look like this:</p><figure name="0bb7" id="0bb7" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*6SdqDql1ofOA1jWePtbHjQ.png" data-width="399" data-height="462" src="https://cdn-images-1.medium.com/max/800/1*6SdqDql1ofOA1jWePtbHjQ.png"></figure><p name="37d3" id="37d3" class="graf graf--p graf-after--figure">Finally, here’s an example with both functions and conditional branches:</p><figure name="a90f" id="a90f" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*6yPMMAAwRKM_IClwKvxwOg.png" data-width="400" data-height="800" src="https://cdn-images-1.medium.com/max/800/1*6yPMMAAwRKM_IClwKvxwOg.png"></figure><h4 name="33f4" id="33f4" class="graf graf--h4 graf-after--figure">Differences from Forth</h4><p name="f5ef" id="f5ef" class="graf graf--p graf-after--h4">Despite borrowing some syntax and conventions from Forth, there are fundamental differences (even beyond tokenization, which is not configurable in kaukatcr).</p><p name="b900" id="b900" class="graf graf--p graf-after--p">One difference is that builtins are not overridden by defined words with the same name. In the reference implementation, user defined function lookup is so much slower than builtins lookup that performing it on every step would be unreasonable for large programs. Furthermore, while redefining builtins is very powerful, it makes the most sense in a system that can easily have its state reset (to revert all possible breaking changes), while ZZ implementations theoretically should be image-based systems (like smalltalk VMs) where every change is automatically saved to persistent state. (Few-to-none of the actual implementations do this, but all of them are supposed to, according to design specs.)</p><p name="2821" id="2821" class="graf graf--p graf-after--p">Another difference is that ‘if’, being non-linear, doesn’t come with ‘else’ and ‘endif’ and friends — instead, it’s essentially a conditional branch. It operates equivalently to the ‘jnz’ instruction in x86 assembly. As a result, ‘if’ can be modified to act as an arbitrary ‘goto’ — just push 1 onto the stack before an if, and you can jump unconditionally to anywhere in the code.</p><p name="8f7b" id="8f7b" class="graf graf--p graf-after--p">In the current implementation, because we jump to the linked cell instead of the clonehead[5] of the linked cell, each cell can be the entrance point for at most one direct branch — however, I see no reason this couldn’t be an implementation-dependent or dialect-dependent decision. Limiting jump points in this way makes analyzing certain structures easier since they collapse into well-defined loops, but circumventing this in order to jump to a particular point from many places involves injecting a bunch of no-op instructions, which should be avoided.[6]</p></div><div class="section-inner sectionLayout--outsetRow" data-paragraph-count="2"><figure name="81d3" id="81d3" class="graf graf--figure graf--layoutOutsetRow is-partialWidth graf-after--p" style="width: 50%;"><img class="graf-image" data-image-id="1*ZhLSui42XuX5vloW8q_HTg.png" data-width="400" data-height="800" src="https://cdn-images-1.medium.com/max/600/1*ZhLSui42XuX5vloW8q_HTg.png"></figure><figure name="1005" id="1005" class="graf graf--figure graf--layoutOutsetRowContinue is-partialWidth graf-after--figure" style="width: 50%;"><img class="graf-image" data-image-id="1*rc7e6TlCYmo5wnhbRDxixA.png" data-width="400" data-height="800" src="https://cdn-images-1.medium.com/max/600/1*rc7e6TlCYmo5wnhbRDxixA.png"><figcaption class="imageCaption" style="width: 200%; left: -100%;">In this contrived example, we show how following clones to their origin (shown via dotted line) might simplify structure. Assume that we have already run the code “def nop ret end”</figcaption></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="f68f" id="f68f" class="graf graf--p graf-after--figure">A third difference is the manipulation of larger data structures. Since all data is either ZZ cells, clones of ZZ cells, or strings or numbers stored in ZZ cells[1], and because ZZ navigation is exposed, it’s natural to use ranks as 1d arrays and to use cells with known sets of dimensions hanging off of them as associative arrays. For multidimensional arrays, I recommend using the convention of d.1, d.2, …, d.n and navigating those structures in the order of the cardinal dimension (i.e., to navigate to (3, 5, 7) we would go three steps along d.1, five steps down d.2, and then seven steps across d.3) — although obviously Kaukatcr is not a good choice for complex matrix arithmetic.</p><figure name="0d58" id="0d58" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*BIoJIChnP6B_s82lXKdQWw.png" data-width="401" data-height="1116" src="https://cdn-images-1.medium.com/max/800/1*BIoJIChnP6B_s82lXKdQWw.png"><figcaption class="imageCaption">A procedure for getting the item at a certain index in a 2d array. On the stack at call time: y-coordinate, x-coordinate, and the cell-id of the head of the matrix.</figcaption></figure><h4 name="4a58" id="4a58" class="graf graf--h4 graf-after--figure">Footnotes</h4><p name="82e0" id="82e0" class="graf graf--p graf-after--h4">[1] Project Xanadu™ is the original hypertext project, formed in 1960 and still going. I worked there, in a volunteer capacity, from 2011 to 2016. It’s the brainchild of Theodor “Ted” Nelson. I recommend looking at <a href="http://xanadu.com" data-href="http://xanadu.com" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">the official website for more details</a>.</p><p name="9b73" id="9b73" class="graf graf--p graf-after--p">[2] To be more accurate, a collection of cells is called a ‘slice’, and a ZZStructure may be composed of one or more slices. The module, as defined, only supports one slice (the ‘cells’ array at module scope). In other implementations, there is a slice class, which handles cell creation, garbage collection, serialization, and the allocation of cell IDs; however, I thought this might be too confusing for people unfamiliar with the concepts I’m trying to introduce. Anyhow, supporting multiple slices is mostly interesting because of the ability to link across slice boundaries — the mechanisms for which were at one time under trade secret. While I believe those trade secret protections are now void, I’m erring on the side of caution by avoiding detailed descriptions or implementations of them.</p><p name="6691" id="6691" class="graf graf--p graf-after--p">[3] The cowcatcher is the wedge-shaped construction found at the front of steam trains. It was invented by Charles Babbage, who also invented the stored-program mechanical computer. We chose this name because of this, and because the movement of the instruction pointer in two dimensions reminded us of a train following tracks. ‘Kaukatcr’ is the phonetic representation of ‘cowcatcher’ in the most popular lojban orthography.</p><p name="ea34" id="ea34" class="graf graf--p graf-after--p">[4] Some of my examples used ‘:’ by accident. So, I believe, did the internal prototype I initially developed. I have modified the implementation to support Forth-style word definitions. Writing and modifying this kind of code is very easy to do with a real zigzag interface, but quite awkward in GIMP!</p><p name="7ced" id="7ced" class="graf graf--p graf-after--p">[5] The ‘clonehead’ is the original from which some cell is cloned, if the cell in question is a clone. Mechanically, cloning works in ZZ by creating a rank of blank cells hanging off the original along d.clone — so, the clonehead is the head of the rank along d.clone. When we get the content/value of a cell, we automatically forward that content request to the clonehead, so from a UI perspective (and the perspective of anything that ‘reads’ the content of a cell) a clone contains the same content as the original.</p><p name="8ff2" id="8ff2" class="graf graf--p graf-after--p graf--trailing">[6] As you can see from the example, dereferencing clones makes certain kinds of code easier to write, but it has ramifications both for how function definition works (since currently it just clones the original function source) and for the regular use of the system. In particular, a user of a ZZ system might expect to be able to clone pieces of data from other programs or from non-code portions of his slice into his code in order to manipulate it, and dereferencing will break this behavior in potentially confusing ways.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@enkiv2" class="p-author h-card">John Ohno</a> on <a href="https://medium.com/p/cc038caafff9"><time class="dt-published" datetime="2018-04-12T22:44:59.229Z">April 12, 2018</time></a>.</p><p><a href="https://medium.com/@enkiv2/kaukatcr-an-experiment-in-language-design-for-multi-dimensional-spaces-cc038caafff9" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on January 21, 2025.</p></footer></article></body></html>