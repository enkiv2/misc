<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>General purpose, in my view, is an overstatement.</title><meta name="description" content="OO is appropriate when the least complicated way of modelling a problem is in terms of agents with internal states communicating. In other…"><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">General purpose, in my view, is an overstatement.</h1>
</header>
<section data-field="subtitle" class="p-summary">
OO is appropriate when the least complicated way of modelling a problem is in terms of agents with internal states communicating. In other…
</section>
<section data-field="body" class="e-content">
<section name="4e71" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="9276" id="9276" class="graf graf--p graf--leading">General purpose, in my view, is an overstatement. (That said, maybe I work with an atypical set of problems.)</p><p name="3d20" id="3d20" class="graf graf--p graf-after--p">OO is appropriate when the least complicated way of modelling a problem is in terms of agents with internal states communicating. In other words, something like a physics engine is a natural fit for OO.</p><p name="148a" id="148a" class="graf graf--p graf-after--p">I mostly work with processing large amounts of text data between formats, occasionally doing analysis. (This is, as far as I can tell, a pretty typical programming job.) This kind of work lends itself well to multiple parallel stages with relatively little state, much of which is short-lived. In other words, it fits well with the UNIX pipeline model, and both OO and FP would be a poor fit. (I’ve had to work with other people’s attempts to shoehorn this kind of process into an OO framework; when I can get away with it, I replace a few thousand lines of Java with two or three lines of shell.) In other words, this is the ‘general case’ for my line of work.</p><p name="6d79" id="6d79" class="graf graf--p graf-after--p">I occasionally come across a circumstance where OO makes sense. I wrote an OS in D, and because D’s object system is similar to C’s structs and unlike C++’s objects, I was able to make excellent use of inheritance &amp; polymorphism for wrapping abstraction around memory-mapped devices like VGA memory; I also made heavy use of object orientation when modeling some novel data structures for Project Xanadu. However, in none of these cases was it convenient or sensible to go full-OO — all of these cases were ‘mixed paradigm’ with a lot of procedural and functional code, and even when I wrote OO, I violated encapsulation whenever I needed to &amp; barely took advantage of inheritance.</p><p name="4360" id="4360" class="graf graf--p graf-after--p">I understand why pedagogy around OO is so popular. After all, human beings deal with objects with internal state in real life all the time, so these concepts are familiar to non-programmers. Likewise, inheritance hierarchies mimic the form that every naive cataloguer produces. But, like John Wilkins in his Essay Towards a Real Character and the imaginary Chinese philosopher in Borges’ Celestial Emporium, we quickly find that reality doesn’t neatly conform to either a hierarchy of relation or a conception of objects with attributes.</p><p name="5b91" id="5b91" class="graf graf--p graf-after--p">In other words, OO is a convenient stepping stone to other paradigms, and is useful in of itself when a mapping of the problem space to a set of objects is either immediately obvious or (in the case of physics engines) provided in the literature, but its most useful attribute is the way in which it demonstrates its own limits. Despite this, because most formally trained software engineers have only ever had serious experience with so-called OO languages &amp; with material that promotes OO to the exclusion of other paradigms, there is the (false, but widespread) belief that the problems introduced by trying to shoehorn the wrong problems into OO are problems of programming in general and are irreducible. The idea that there is such a thing as a general purpose programming paradigm that is ‘good enough’ for anything, while convenient for casual developers who would like to avoid learning more than the basics of a single language, supports this essentially artificial set of problems.</p><p name="d0be" id="d0be" class="graf graf--p graf-after--p">The current boom in interest in functional programming is hardly unexpected: you teach people that the one true paradigm is a bastard mix of OO and procedural programming for twenty years and that it’s the end of history, and as soon as they are exposed to an alternative they’ll jump all over it: most problems introduced by OO are artifacts of OO and dissolve as soon as you break out of it, but FP has similar artifacts.</p><p name="daf8" id="daf8" class="graf graf--p graf-after--p graf--trailing">Poor CS pedagogy is a bit of a hobby horse for me. OO is as it is, and I don’t have anything against it as such, but the idea that OO is generally applicable (or, more generally applicable than some other given paradigm) is getting in the way of professors and authors realizing that all serious developers need to have a full toolbox. The current miserable state of the development world is a result of every developer having a pair of vice grips &amp; nothing else — and while you can solve pretty much any problem after a fashion with a pair of vice grips and a few hours of fiddling, you end up with a lot of mangled screws and bloodied fingernails.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@enkiv2" class="p-author h-card">John Ohno</a> on <a href="https://medium.com/p/422d7a8d58e1"><time class="dt-published" datetime="2016-07-25T14:10:11.914Z">July 25, 2016</time></a>.</p><p>Exported from <a href="https://medium.com">Medium</a> on June 13, 2017.</p></footer></article>

</body></html>