<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Exocortex tools part I: social media automation with very small shell scripts</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Exocortex tools part I: social media automation with very small shell scripts</h1>
</header>
<section data-field="subtitle" class="p-summary">
Exocortex Tools is a series describing my personal set of utility shell scripts. The term ‘Exocortex tool’ in this context comes from…
</section>
<section data-field="body" class="e-content">
<section name="d8c0" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="51d7" id="51d7" class="graf graf--h3 graf--leading graf--title">Exocortex tools part I: social media automation with very small shell scripts</h3><p name="ffb0" id="ffb0" class="graf graf--p graf-after--h3"><em class="markup--em markup--p-em">Exocortex Tools is a series describing my personal set of utility shell scripts. The term ‘Exocortex tool’ in this context comes from @</em><a href="https://medium.com/@VirtualAdept" data-href="https://medium.com/@VirtualAdept" class="markup--anchor markup--p-anchor" target="_blank"><em class="markup--em markup--p-em">VirtualAdept</em></a><em class="markup--em markup--p-em">, but this does not represent his toolchain. This entry will be focusing on </em><a href="https://github.com/enkiv2/misc/blob/master/post" data-href="https://github.com/enkiv2/misc/blob/master/post" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><em class="markup--em markup--p-em">post</em></a><em class="markup--em markup--p-em">, </em><a href="https://github.com/enkiv2/misc/blob/master/links.sh" data-href="https://github.com/enkiv2/misc/blob/master/links.sh" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><em class="markup--em markup--p-em">links.sh</em></a><em class="markup--em markup--p-em">, and </em><a href="https://github.com/enkiv2/misc/blob/master/notes.sh" data-href="https://github.com/enkiv2/misc/blob/master/notes.sh" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><em class="markup--em markup--p-em">notes.sh</em></a><em class="markup--em markup--p-em">.</em></p><p name="60b5" id="60b5" class="graf graf--p graf-after--p">There’s a lot of interest in cross-posting tools &amp; alternatives to traditional web-based centralized social media lately. I have been using a toolchain I wrote myself for several years, and I have avoided describing it until now because the tools I wrote are so simple that I didn’t consider them worth describing. However, I’ve seen a lot of people using webtech or otherwise doing much more work than necessary, while failing to achieve feature parity with what I’ve got.</p><p name="b668" id="b668" class="graf graf--p graf-after--p">When it comes to any form of automation, the unix shell is your friend: it will allow you to compose existing tools together with a minimum of fuss, and existing tools are typically pretty well-suited to using it (or else programs like curl are well-suited to bridge that gap).</p><p name="721c" id="721c" class="graf graf--p graf-after--p">In my particular case, I have a presence on a variety of social networking sites, only a few of which have IFTTT integration, and I would like to automate the broadcast of certain types of posts. In particular, I want the ability to post arbitrary microblogs to all services simultaneously, the ability to post links with automatically-fetched titles, and to have those links show up in a pinboard-like minimal interface on my website. Furthermore, I would like integration with a system for short plaintext notes I already keep.</p><p name="c9de" id="c9de" class="graf graf--p graf-after--p">The easiest problem to solve is the problem of simultaneous broadcast. There is a command-line tool for posting to almost every social network. In my case, I use the ruby gem ‘t’ for twitter, the pip package ‘tootstream’ for the fediverse, the npm package ‘sbot’ for secure scuttlebutt, and the twtxt command line client for twtxt, while relying upon IFTTT to relay twitter posts elsewhere (since twitter is the only microblogging service mentioned above that IFTTT knows about). <a href="https://github.com/enkiv2/misc/blob/master/post" data-href="https://github.com/enkiv2/misc/blob/master/post" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">The shell script is VERY small</a>.</p><pre name="585e" id="585e" class="graf graf--pre graf-after--p">#!/usr/bin/env zsh                       <br>args=&quot;$@&quot;                       <br>t post &quot;$args&quot;                       <br>yes | twtxt tweet &quot;$args&quot;                       <br>echo -e &quot;toot -v $args\nu&quot; | tootstream                       <br>sbot publish --type post --text &quot;$args&quot;</pre><p name="36de" id="36de" class="graf graf--p graf-after--pre">This tool is named ‘post’ &amp; it does what it says on the tin: it posts the args (quoted or otherwise) everywhere I care about. Posts that are too long for twitter will fail to post there and merely be posted to the other services (which have larger maximum post sizes).</p><p name="29b1" id="29b1" class="graf graf--p graf-after--p">As for links, the problem is slightly more difficult. We need a format for storing link information permanently, a mechanism to transform the list of links into a web page, and a mechanism to add a link to the list.</p><p name="b8dc" id="b8dc" class="graf graf--p graf-after--p">I decided to use a three-column TSV to store link information. I append lines to the end, so the resulting file is in chronological order. The columns are: URL, time, and (optional) title.</p><p name="63cc" id="63cc" class="graf graf--p graf-after--p">Producing a static HTML file from this is straightforward: we produce the beginning and end of the HTML file, then (reading the list of links backwards) produce an entry for each.</p><pre name="0137" id="0137" class="graf graf--pre graf-after--p">function fmtlinks() {           <br>    echo &quot;&lt;html&gt;&quot;                        <br>    echo &#39;&lt;head&gt;&lt;title&gt;Links&lt;/title&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;vt240.css&quot;&gt;&lt;/head&gt;&#39;                        <br>    echo &quot;&lt;body&gt;&quot;                        <br>    echo &quot;&lt;table&gt;&quot;                        <br>    echo &quot;&lt;tr&gt;&lt;th&gt;Link&lt;/th&gt;&lt;th&gt;Date&lt;/th&gt;&lt;/tr&gt;&quot;                        <br>    tac ~/.linkit| <br>        awk &#39;<br>            BEGIN{FS=&quot;\t&quot;} <br>            {<br>                title=$1; <br>                if($3) title=$3; <br>                print &quot;&lt;tr&gt;&lt;td&gt;&lt;a href=\&quot;&quot; $1 &quot;\&quot;&gt;&quot; title &quot;&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&quot; $2 &quot;&lt;/td&gt;&lt;/tr&gt;&quot;<br>             }&#39;                        <br>    echo &quot;&lt;/table&gt;&quot;                        <br>    echo &quot;&lt;center&gt;&lt;a href=\&quot;https://github.com/enkiv2/misc/blob/master/links.sh\&quot;&gt;Generated with links.sh&lt;/a&gt;&lt;/center&gt;&quot;                        <br>    echo &quot;&lt;/body&gt;&quot;                        <br>    echo &quot;&lt;/html&gt;&quot;                       <br>}</pre><p name="0254" id="0254" class="graf graf--p graf-after--pre">The only logic in the center is to use the URL as the title if the title entry is empty. This is a small &amp; simple script, and could be made shorter if I sacrificed readability. Because HTML is a nightmare, I have erred on the side of clarity over terseness.</p><p name="3e75" id="3e75" class="graf graf--p graf-after--p">The most complicated part of adding links is fetching their title, and the most complicated part of fetching link titles is dealing with strange nonstandard HTML escape logic. Here is my title-fetching code:</p><pre name="cc3c" id="cc3c" class="graf graf--pre graf-after--p">function getTitle() {                        <br>    curl &quot;$1&quot;| grep -a -i &quot;&lt;title&gt;&quot; | head -n 1 | <br>    sed &#39;s/^.*&lt;[tT][iI][tT][lL][eE]&gt;//;s/&lt;\/[tT][iI][tT][lL][eE]&gt;.*//&#39; |                          <br>    sed &#39;s/&amp;#039\;/&#39;&quot;&#39;&quot;&#39;/g;s/&amp;#39\;/&#39;&quot;&#39;&quot;&#39;/g;s/&amp;quot\;/&quot;/g&#39; |                          <br>    tr &#39;\221\222\223\224\226\227&#39; &#39;\047\047&quot;&quot;--&#39;                       <br>}</pre><p name="d699" id="d699" class="graf graf--p graf-after--pre">First I pull down the HTML into a pipe, so the fetch for a large page will actually be aborted once I have found the first title tag, then I remove everything before the end of the open tag and everything after the end of the close tag. After that, all of the logic is related to processing common HTML escapes and stripping commonly-found but invalid characters (like ‘smartquotes’).</p><p name="8bdd" id="8bdd" class="graf graf--p graf-after--p">Adding a link involves a few steps: we must get the title, create a truncated title so that both title and URL will fit on twitter, and post the result (if it exists). I additionally use Vice Motherboard’s “mass_archive” script to add any URL in my link archive to the wayback machine and archive.is.</p><pre name="489d" id="489d" class="graf graf--pre graf-after--p">function linkit() {                        <br>    (which mass_archive 2&gt;&amp;1 &gt; /dev/null &amp;&amp; mass_archive &quot;$1&quot;)                        <br>    export LC_ALL=en_US.UTF-8                        <br>    echo -e &quot;$1\t$(date)\t$(getTitle &quot;$1&quot;)&quot; &gt;&gt; ~/.linkit                        <br>    post=&quot;$(<br>        export LC_ALL=en_US.UTF-8 ; <br>        tail -n 1 ~/.linkit | awk &#39;<br>            BEGIN{FS=&quot;\t&quot;} <br>            {<br>                url=$1 ; <br>                title=$3 ; <br>                if(url!=title &amp;&amp; title!=&quot;&quot;&amp;&amp;title!=&quot; &quot;) {<br>                    if(length(url)+length(title)&gt;=280) {<br>                        delta=(length(url)+length(title))-280;            <br>                        delta+=4; <br>                        if(delta&lt;length(title)) { <br>                            title=substr(title, 0, length(title)-delta) &quot;...&quot; ; <br>                             print title &quot; &quot; url <br>                        } <br>                    } else print title &quot; &quot; url <br>                  } <br>             }&#39; | <br>         grep -a . | head -n 1 | recode -f UTF8)&quot;                        <br>     [[ -n &quot;$post&quot; ]] &amp;&amp; post &quot;$post&quot;                        <br>     stty sane                       <br>}</pre><p name="2d35" id="2d35" class="graf graf--p graf-after--pre">We first run mass_archive if it exists in the path. Then, we write an entry to the link archive TSV. We read the final entry in that TSV, pull out the URL and title, and if the combined size of the URL and the title is more than 280 characters, we truncate only the title portion, adding an elipsis at the end. If the URL itself is longer than 280 characters, we instead emit an empty string. Once we’ve done that, we grab only the first line (in the rare case that a title will somehow emit a newline) and force the encoding to UTF8. Having done that, we post.</p><p name="5ee0" id="5ee0" class="graf graf--p graf-after--p">The final line, ‘stty sane’, exists only to clean up glitches that sometimes occur when curses-based clients (like tootstream) exit before cleanup — for instance, if I force-killed it before it had finished posting a link.</p><p name="4a4b" id="4a4b" class="graf graf--p graf-after--p">The remaining function in our link-archive system is just a helper method for upload:</p><pre name="dffb" id="dffb" class="graf graf--pre graf-after--p">function uploadlinks() {                        <br>    fmtlinks &gt; ~/index.html                        <br>    scp ~/index.html $1                       <br>}</pre><p name="9946" id="9946" class="graf graf--p graf-after--pre">My note system is just a plain text file, to which I append single lines, with a handful of helper functions. I have special post-related helper functions for ‘band name of the day’ (which I add to my notes, since I mostly use that feature for storing interesting turns of phrase) and ‘bad idea of the day’ (which I post but do not add to notes).</p><pre name="80c4" id="80c4" class="graf graf--pre graf-after--p">#!/usr/bin/env zsh                                               <br>[[ -e ~/.notes ]] || touch ~/.notes                                               <br>function addnote() {                        <br>    read x                         <br>    echo &quot;$x&quot; &gt;&gt; ~/.notes                       <br>}                       <br>function rnote() {                        <br>    if [[ $# -eq 0 ]] ; then                         <br>        shuf -n 1 ~/.notes                        <br>    else                         <br>        egrep &quot;$@&quot; ~/.notes | shuf -n 1                        <br>    fi                       <br>}                       <br>function gnote() {                        <br>    egrep &quot;$@&quot; ~/.notes                       <br>}                       <br>function lnote() {                        <br>    if [[ $# -eq 0 ]] ; then                         <br>        tail -n 1 ~/.notes                        <br>    else                         <br>        tail -n &quot;$@&quot; ~/.notes                        <br>    fi                       <br>}                                               <br>bnotd ()                        <br>{                            <br>    echo &quot;$@&quot; | addnote;                           <br>    post &quot;Band name of the day: $@&quot;                       <br>}                       <br>biotd ()                        <br>{                            <br>    post &quot;Bad idea of the day: $@&quot;                       <br>}</pre><h4 name="a9ea" id="a9ea" class="graf graf--h4 graf-after--pre">Conclusion</h4><p name="f165" id="f165" class="graf graf--p graf-after--h4">This is not a pretty system. It’s not necessarily an efficient system. However, it’s an extremely straightforward, low-effort system that works reliably enough for its intended goals.</p><p name="5043" id="5043" class="graf graf--p graf-after--p">Since it’s an idiosyncratic system built specifically for my needs, it presents features that other users will not desire. So, I don’t recommend anyone adopt it. However, let it be seen as evidence that this kind of thing can be done with very small shell scripts, and with next to zero developer effort.</p><p name="d813" id="d813" class="graf graf--p graf-after--p">Every time I see someone implement a trivial static-site generator and then decide to use a web service to post to it, I die a little inside: why not eliminate the most irritating thing about any website (the web portion)? The answer is probably “I didn’t think of it”.</p><p name="c0ac" id="c0ac" class="graf graf--p graf-after--p graf--trailing">Well, now you’ve thought of it.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@enkiv2" class="p-author h-card">John Ohno</a> on <a href="https://medium.com/p/62d995242a57"><time class="dt-published" datetime="2018-06-15T16:53:54.715Z">June 15, 2018</time></a>.</p><p><a href="https://medium.com/@enkiv2/exocortex-tools-part-i-social-media-automation-with-very-small-shell-scripts-62d995242a57" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on February 14, 2022.</p></footer></article></body></html>