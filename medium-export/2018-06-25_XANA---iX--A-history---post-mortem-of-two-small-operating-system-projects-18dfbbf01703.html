<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>XANA &amp; iX: A history &amp; post-mortem of two small operating system projects</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">XANA &amp; iX: A history &amp; post-mortem of two small operating system projects</h1>
</header>
<section data-field="subtitle" class="p-summary">
In 2007, after years of reading about OS development &amp; writing only toy projects in that vein, I wrote my first ‘serious’ small OS —…
</section>
<section data-field="body" class="e-content">
<section name="c002" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="ee7b" id="ee7b" class="graf graf--h3 graf--leading graf--title">XANA &amp; iX: A history &amp; post-mortem of two small operating system projects</h3><p name="a095" id="a095" class="graf graf--p graf-after--h3">In 2007, after years of reading about OS development &amp; writing only toy projects in that vein, I wrote my first ‘serious’ small OS — serious in the sense that it used protected mode, had a filesystem, &amp; had a marginally-usable UI. Three years later, I wrote another OS incorporating the lessons I learned from the first. Both of these projects are failures as usable OS projects but successes in other ways.</p><p name="d1d3" id="d1d3" class="graf graf--p graf-after--p">I’d like to describe them, briefly, in case they might be of interest to other aspiring osdev hobbyists (if only as a warning). I’d also like to describe them in order to indulge in a bit of reminiscence: writing OS experiments is time-consuming, even when they are this small, and while I found the experience enjoyable, I no longer have the spare energy to work on such things — full-time employment has made it impossible.</p><p name="6eca" id="6eca" class="graf graf--p graf-after--p">Both of these projects incorporated Project Xanadu ideas as I understood them at the time. My understanding of these ideas was largely incorrect. For an accurate overview of them from a technical perspective, I recommend reading <a href="https://hackernoon.com/an-engineers-guide-to-the-docuverse-d080cdbb73a6" data-href="https://hackernoon.com/an-engineers-guide-to-the-docuverse-d080cdbb73a6" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">my essay on the subject</a>. I will not be covering the actual concepts I mis-understood except shallowly (to illuminate the ways in which my implementations differed from them).</p><p name="c81e" id="c81e" class="graf graf--p graf-after--p">The history I sketch is from memory, and I haven’t made an effort to verify beyond looking at commit history. So, circumstances I describe are largely a description of my understanding at the time, filtered through a decade of working on other things — and at the time I worked on these projects, I was both substantially greener as a developer and perpetually sleep-deprived. If there aren’t errors in the chronology of external events, or outright misunderstandings of them, I would be very surprised.</p><h4 name="942b" id="942b" class="graf graf--h4 graf-after--p">2007: Project XANA</h4><p name="b794" id="b794" class="graf graf--p graf-after--h4">Someone in the freenode #d IRC channel, Alexander Panek, began work on an OS kernel in D some time in 2006 or early 2007, then abandoned it. In early 2007, having been interested in OS development for some time, I read the kernel-in-progress (which consisted of <a href="https://github.com/enkiv2/projectxana/blob/master/src/klib/Multiboot.d" data-href="https://github.com/enkiv2/projectxana/blob/master/src/klib/Multiboot.d" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">a multiboot header in D</a>, maybe a hundred lines of assembly for getting from the bootloader to an entry point and <a href="https://github.com/enkiv2/projectxana/blob/master/src/klib/Stdout.d" data-href="https://github.com/enkiv2/projectxana/blob/master/src/klib/Stdout.d" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">a small module for VGA text</a>) and ported it from the Digital Mars compiler to GDC (a then-third-party patchset adding D support to GCC).</p><p name="62d2" id="62d2" class="graf graf--p graf-after--p">This was around the time that a major version of the language had been released, and GDC was playing catch-up; I was running a source-based distro, and couldn’t easily get the Digital Mars binaries to run on it. At the same time, as a related but theoretically-separate effort, lots of people were jumping from the default standard library (phobos) to a new replacement standard library (which I believe was called deimos), and I was unable to get deimos to work with my GDC install (although I also didn’t understand why people preferred it — it had features whose use I didn’t comprehend). I had been hanging out in the channel for months but writing only toy programs (and probably not even compiling the ones I wrote). However, I graduated high school in January or February of that year &amp; began taking a handful of classes at a nearby university, and this gave me enough time to dive head-first into the language.</p><p name="3b3d" id="3b3d" class="graf graf--p graf-after--p">Almost all of the original D code for the kernel ended up being rewritten: the assembly code was rendered unnecessary by GRUB (though I also wrote my own bootloader at some point in the development), and the remaining D code was in VGA module features for things like smooth scrolling that didn’t match my display model or for things like wrapping single GDT/IDT-interface instructions (which might have worked with DMD-generated code but wouldn’t work with GDC-generated code because the registers got filled with unrelated data). However, the brunt of the work actually occurred before getting anything to boot.</p><p name="7911" id="7911" class="graf graf--p graf-after--p">It’s unclear to what extent DMD generated code that was actually dependent upon Phobos (or Deimos). However, this version of GDC emitted endless references to Phobos routines, and so D code was used internally even for things you might expect to have no dependencies; furthermore, this D code had dependencies on libc routines, many of which were provided by the OS. For instance, D has optional garbage collection, and all of the garbage collection routines are in D itself — so declaring a variable depended upon malloc, hashing functions, syscalls to get the time, and a variety of other unexpected things. I spent weeks doing nothing but commenting out parts of Phobos and replacing them with mocks that return static values.</p><p name="37bb" id="37bb" class="graf graf--p graf-after--p">Eventually, with the help of a couple math-related routines from a public-domain-licensed all-assembly-language libc implementation &amp; a couple headers taken from GCC itself, I got a kernel that could build &amp; display words on a screen. Mostly, I got a strong lesson in separation of concerns: it is very difficult to extract OS and libc dependencies from a complex high-level library that was never designed to make such an extraction straightforward. The phobos code I could read was deeply entangled with generated code I couldn’t, which had C dependencies I couldn’t predict, and rewriting large portions of the libc was not in the cards. After all, I had taken up the task of writing the first OS in D, and so it simply wouldn’t do to have the codebase be mostly C and assembly, even at an early stage!</p><p name="55d0" id="55d0" class="graf graf--p graf-after--p">(Luckily, Phobos was also public-domain licensed. My changes were ad-hoc but substantial enough that they couldn’t easily be applied at build-time, particularly to a moving target: I essentially had my own broken, gutted phobos fork.)</p><p name="b019" id="b019" class="graf graf--p graf-after--p">Being a giant dork, I named my kernel Project XANA — a combination of Project Xanadu (with which I had been obsessed for at least four years already) and XANA, the antagonist of the mediocre french animated children’s television show Code Lyoko (which I didn’t watch, but which I respected on the grounds that shows about virtual reality were relatively thin on the ground).</p><p name="16e1" id="16e1" class="graf graf--p graf-after--p">Once I got the kernel running, I implemented <a href="https://github.com/enkiv2/projectxana/blob/master/src/klib/Stdin.d" data-href="https://github.com/enkiv2/projectxana/blob/master/src/klib/Stdin.d" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">keyboard support</a>, which required modifying the IDT (and thus the GDT). I had switched to GRUB by this point, since my bootloader, which did the switch into protected mode itself, couldn’t read the kernel’s symbol table &amp; therefore couldn’t jump to a non-static address. Since GRUB had set up the IDT and GDT initially during its switch into protected mode, I hadn’t needed to work with them since the switch, and writing a full IDT in D ended up being relatively difficult: the tricks that the author of the original code I was working off of (now mostly rewritten anyhow) didn’t work in GDC (if they ever did in DMD — considering the absence of a similarly gutted Phobos in that project, probably not), and so <a href="https://github.com/enkiv2/projectxana/blob/master/src/klib/idt.d" data-href="https://github.com/enkiv2/projectxana/blob/master/src/klib/idt.d" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">I had to invent my own</a>. Getting the keyboard working was probably a few weeks’ worth of work on the grounds that, rather than looking things up, I was working by trial and error.</p><p name="c2d3" id="c2d3" class="graf graf--p graf-after--p">At this point, high on having something working, I started dumping Xanadu concepts into the design.</p><p name="058c" id="058c" class="graf graf--p graf-after--p">Since the kernel at the time produced a file named ‘stage2’ (after grub’s stage1 and stage1.5 files), I broke development into stages: the kernel up to this point was ‘stage2’, while the next stage, which implemented a document storage system, was ‘estage’ (‘e’ for ‘enfilade’). I actually didn’t use enfilades — I had tumbler-indexed hash tables, with a custom hashing algorithm that was so slow that it ended up being worse than linear search. I also implemented a document system with span-to-span hyperlinks. I had to reintroduce previously-removed parts of phobos in order to make any of this work.</p><p name="de77" id="de77" class="graf graf--p graf-after--p">Then, I implemented an interactive frontend. Keeping with the Code Lyoko theme, I called it <a href="https://github.com/enkiv2/projectxana/blob/master/src/aileta/aileta.d" data-href="https://github.com/enkiv2/projectxana/blob/master/src/aileta/aileta.d" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Aileta </a>(after one of the protagonists, who was probably named after Alita, Princess of Mars). I took inspiration from ZigZag &amp; from the PlayStation 3’s “cross-bar” menu system, and treated the first character of any document as an icon for that document. (I had set up keyboard input handling so that control+character produced the character with the ASCII code of that character minus 92, and chose to display control codes, so the graphic &amp; line-drawing characters prior to ASCII 65 were easily accessible, though one would need to memorize them.) The first forward- and back-links were used to arrange the document icons into a navigable cross-shaped menu.</p><p name="d59c" id="d59c" class="graf graf--p graf-after--p">After implementing this, I started work on hard disk support, which required writing PIC and IRQ manipulation code. I made the disk map directly to the in-memory structure used for the document storage structure, which ultimately meant making <a href="https://github.com/enkiv2/projectxana/blob/master/src/klib/estage/mmdisk.d" data-href="https://github.com/enkiv2/projectxana/blob/master/src/klib/estage/mmdisk.d" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">a wrapper for disk routines that, to an outside observer, looked like a byte array or a void pointer</a>. These routines never got a workout on a real disk — only in emulation. I was able to happily trigger formats (which took in excess of half an hour) but I never tested reading from this structure after a reboot. I also brought in a full Lua implementation and removed system &amp; libc dependencies — the idea being that Lua code in documents would be the primary way of developing within the system.</p><p name="09d6" id="09d6" class="graf graf--p graf-after--p">Ultimately, this project was a mess: to the extent that it was functional, it was unusably slow; it suffered from the use of a very high-level language (which needed to be tamed), and while it made use of some of the features provided by that language, it was limited in the use of those features by functionality that needed to be removed. In only a few cases was the use of D beneficial: VGA manipulation was nominally easier than in C because of the module system and because structs act as pseudo-objects with member functions not mapped to allocated memory, and making a hard disk look like a byte array, while it wouldn’t really be possible in C, also isn’t a particularly sensible thing to do.</p><p name="28a6" id="28a6" class="graf graf--p graf-after--p">Nevertheless, being able to prototype low-level structures in D made certain things easier, on a conceptual level. Many of the ideas that eventually made their way into iX were prototyped in XANA, because structures that were unthinkable to me in C were idiomatic in D, and it turned out that those structures ported back into C nicely.</p><p name="2ee5" id="2ee5" class="graf graf--p graf-after--p">XANA cannot build on modern versions of GDC or DMD. As far as I know, nobody else has attempted to write an OS mostly or primarily in D, although people write OSes in C++ all the time &amp; would have similar problems. (I suspect that an OS written in Rust or Go would also run into these issues — whereas, with C++, there are well-understood best-practices and minimal standard libraries specifically to minimize the impact of these problems.)</p><h4 name="1b02" id="1b02" class="graf graf--h4 graf-after--p">2010: iX</h4><p name="4042" id="4042" class="graf graf--p graf-after--h4">In 2010 I took an operating systems class &amp; remembered how much (masochistic) fun writing XANA was. So, I started writing a new OS in C, cribbing some ideas from XANA. Specifically, I translated XANA’s multiboot header back into C, copied the linker script, and did another ZigZag variation for the front-end.</p><p name="91fd" id="91fd" class="graf graf--p graf-after--p">Since I was writing C, I had the ability to control precisely which standard library features I wanted to use, and (in fact) to break compatibility in some cases. So, I implemented <a href="https://github.com/enkiv2/ix/blob/master/src/util.c" data-href="https://github.com/enkiv2/ix/blob/master/src/util.c" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">only a handful of them</a>.</p><p name="180c" id="180c" class="graf graf--p graf-after--p">Rather than port back the IDT routines I had written for XANA, I worked off of a tutorial for OSdev in C — bkerndev. The IDT, GDT, and IRQ files are the only code in this project that I didn’t write. (Had I written them myself I would have written them in assembly. I still don’t have 100% understanding of what Bran is doing in this code or why, even though I’ve written equivalent code in assembly and in D. Replacing them while keeping compatibility was deemed low-priority.) I backported some ideas from my XANA keyboard handling code and combined them with ideas from bkerndev to produce <a href="https://github.com/enkiv2/ix/blob/master/src/kb.c" data-href="https://github.com/enkiv2/ix/blob/master/src/kb.c" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">a fairly small keyboard handler</a>.</p><p name="4af6" id="4af6" class="graf graf--p graf-after--p">Once again, I made the on-disk format mimic the in-memory structure for user data, which itself was informed by the UI. However, since this was a design decision from the outset, I made sure to make the formats straightforward to implement, resistant to serialization problems. <a href="https://github.com/enkiv2/ix/blob/58aa860935505bf5dc62bc0f0bd3af4dc43f6896/src/zz.c#L70" data-href="https://github.com/enkiv2/ix/blob/58aa860935505bf5dc62bc0f0bd3af4dc43f6896/src/zz.c#L70" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">This meant having a static-length preallocated memory structure with static-length fields.</a> (We never make new cells or new dimensions; instead, we fill in connections, or fill in pre-allocated cells. All cell content is also of a fixed maximum length, with zero termination truncating it.)</p><p name="6a6c" id="6a6c" class="graf graf--p graf-after--p">Unlike XANA’s interface, I had functional dimension-switching in iX. However, the dimensions were not named (only numbered), and I didn’t have clones, so iX is not a proper ZigZag implementation.</p><p name="a34f" id="a34f" class="graf graf--p graf-after--p">Rather than trying to import a conventional language, I started work on <a href="https://github.com/enkiv2/ix/blob/master/src/kaukatcr.c" data-href="https://github.com/enkiv2/ix/blob/master/src/kaukatcr.c" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">an early version</a> of <a href="https://hackernoon.com/kaukatcr-an-experiment-in-language-design-for-multi-dimensional-spaces-cc038caafff9" data-href="https://hackernoon.com/kaukatcr-an-experiment-in-language-design-for-multi-dimensional-spaces-cc038caafff9" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">kaukactr</a>, which was to be the internal language for development on this system. I didn’t get as far as to even write function decoding in this implementation, but the original plans would have already been mapped out by the time I wrote this code. I also integrated it into the <a href="https://github.com/enkiv2/ix/blob/master/src/timer.c" data-href="https://github.com/enkiv2/ix/blob/master/src/timer.c" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">task-switching code</a>, which switched between tasks every jiffy and used the normal timer interrupt.</p><p name="d9ce" id="d9ce" class="graf graf--p graf-after--p">ZigZag and Kaukatcr were a good fit for an OS written in a low-level language like C: they don’t require complicated structures that benefit significantly from abstraction layers, and serialization can be made straightforward. I could have supported named dimensions, clones, and a proper/full kaukactr implementation without much effort.</p><p name="c075" id="c075" class="graf graf--p graf-after--p">iX has fairly clean code (particularly compared to XANA), although when drawing boxes and graphical structures it tends to get long &amp; hard to read — it would benefit from refactoring, specifically with the introduction of dedicated drawing routines. I avoided using unusual C features (even if such features might be fairly common in OS dev) &amp; tried to make the code small and clear. I didn’t implement anything unnecessary — iX is minimalist where XANA is maximalist.</p><h4 name="6a9c" id="6a9c" class="graf graf--h4 graf-after--p">Conclusion</h4><p name="29e1" id="29e1" class="graf graf--p graf-after--h4">Neither of these projects is going to storm the world. In fact, neither is even going to have the kind of small-but-enthusiastic user base that Menuet has. However, I think they demonstrate some useful ideas, some of which are at odds with recieved wisdom in OS development:</p><ol class="postList"><li name="8ea1" id="8ea1" class="graf graf--li graf-after--p">It’s possible and potentially rewarding to make use of high-level language features in an OS development context, provided you can minimize the runtime dependencies of those features.</li><li name="936e" id="936e" class="graf graf--li graf-after--li">It’s possible and potentially rewarding to write an OS as a standalone experiment in UI design, and to make the structure of the OS mirror your UI design. This is easier in minimalist systems, where irrelevant features that might make the OS usable are eliminated in favor of conceptual simplicity. The OS becomes an art project.</li><li name="60bb" id="60bb" class="graf graf--li graf-after--li">If you avoid the goals of compatibility, usability, and widespread adoption, difficult problems (task switching, filesystem design, interfacing with storage media) become straightforward.</li><li name="34f6" id="34f6" class="graf graf--li graf-after--li graf--trailing">There’s room for thousands of art-project OSes, in a way that there isn’t for even hundreds of UNIX clones.</li></ol></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@enkiv2" class="p-author h-card">John Ohno</a> on <a href="https://medium.com/p/18dfbbf01703"><time class="dt-published" datetime="2018-06-25T17:13:53.178Z">June 25, 2018</time></a>.</p><p><a href="https://medium.com/@enkiv2/xana-ix-a-history-post-mortem-of-two-small-operating-system-projects-18dfbbf01703" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on September 18, 2020.</p></footer></article></body></html>